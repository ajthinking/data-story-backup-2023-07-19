
You will be given a project as a JSON file.

Your task is to write the Readme file.
It should be suitable to put on github.
It should contain emojis, code examples and more.

Here comes the JSON:

{
  "Computer.ts": "type NextResult = undefined\ntype ReturnResult = void | never\ntype NextArgument = void\n\nimport { InputDeviceInterface } from \"./InputDevice\"\nimport { Item } from \"./Item\"\nimport { OutputDeviceInterface } from \"./OutputDevice\"\nimport { Param } from \"./Param\"\nimport { ParamsDevice } from \"./ParamsDevice\"\n\nexport type RunArgs = {\n  input: InputDeviceInterface,\n  output: OutputDeviceInterface,\n  params: ParamsDevice,\n  storage?: any,\n}\n\nexport interface Computer {\n  name: string\n  inputs?: string[]\n  outputs?: string[]\n  params?: Record<string, Param>\n  tags?: string[]\n\n  run: (args: RunArgs) => AsyncGenerator<NextResult, ReturnResult, NextArgument>\n  canRun?: (options: any) => boolean\n}\n\nexport type ComputerFactory = (options?: any) => Computer",
  "Diagram.ts": "import { Link } from \"./Link\"\nimport { Node } from \"./Node\"\nimport { Port, PortId } from \"./Port\"\n\nexport class Diagram {\n  constructor(\n    public nodes: Node[],\n    public links: Link[],\n  ) {}\n\n  linksConnectedToPortId(id: PortId): Link[] {\n    return this.links.filter(link => link.sourcePortId === id || link.targetPortId === id)\n  }\n}",
  "DiagramBuilder.ts": "import { Computer, ComputerFactory } from \"./Computer\";\nimport { Diagram } from \"./Diagram\";\nimport { Link } from \"./Link\";\nimport { Node } from \"./Node\";\nimport { Port } from \"./Port\";\n\nexport class DiagramBuilder {\n  diagram: Diagram\n  previousNode: Node | null = null\n\n  constructor() {\n    this.diagram = new Diagram([], [])\n  }\n\n  add(addable: ComputerFactory | Computer) {\n    const computer = typeof addable === 'function' ? addable() : addable\n\n    const nodeId = `${computer.name}.${this.getScopedId(computer.name)}`\n\n    const node = new Node({\n      id: nodeId,\n      type: computer.name,\n      inputs: (computer.inputs ?? []).map(name => {\n        return new Port(`${nodeId}.${name}`, name)\n      }),\n      outputs: (computer.outputs ?? []).map(name => {\n        return new Port(`${nodeId}.${name}`, name)\n      }),\n    })\n\n    this.diagram.nodes.push(node)\n    \n    if (this.previousNode) this.linkToPrevious(node)\n\n    this.previousNode = node\n\n    return this\n  }\n\n  get() {\n    return this.diagram\n  }\n\n  protected getScopedId(computerName: string) {\n    const max = this.diagram.nodes\n      .filter(node => node.type === computerName)\n      .map(node => node.id)\n      .map(id => id.split('.')[1])\n      .map(id => parseInt(id))\n      .reduce((max, id) => Math.max(max, id), 0)\n\n    return max + 1      \n  }\n\n  protected linkToPrevious(newNode: Node) {\n    const previousNode = this.previousNode!\n\n    const previousNodePort: Port | undefined = previousNode.outputs[0]\n    const newNodePort: Port | undefined = newNode.inputs[0]\n\n    if(!previousNodePort || !newNodePort) return\n\n    const link = new Link(\n      `${previousNodePort.id}-->${newNodePort.id}`,\n      previousNodePort.id,\n      newNodePort.id,\n    )\n\n    this.diagram.links.push(link)\n  }\n}",
  "DiagramFactory.ts": "import { Diagram } from \"./Diagram\"\nimport { Link } from \"./Link\"\nimport { Node } from \"./Node\"\nimport { Port } from \"./Port\"\n\n/*\n{\n  \"nodes\": [\n    {\n      \"width\": 128,\n      \"height\": 52,\n      \"id\": \"Signal0.7993711459744541\",\n      \"position\": {\n        \"x\": 101.2618246308146,\n        \"y\": 202.66893570290534\n      },\n      \"data\": {\n        \"computer\": \"Signal\",\n        \"label\": \"Signal\",\n        \"inputs\": [],\n        \"outputs\": [\n          {\n            \"id\": \"Signal0.7993711459744541-undefined\"\n          }\n        ]\n      },\n      \"type\": \"dataStoryNode\",\n      \"selected\": false,\n      \"positionAbsolute\": {\n        \"x\": 101.2618246308146,\n        \"y\": 202.66893570290534\n      },\n      \"dragging\": false\n    },\n    {\n      \"width\": 128,\n      \"height\": 78,\n      \"id\": \"Pass0.0906613692536935\",\n      \"position\": {\n        \"x\": 373.1397321248163,\n        \"y\": 201.0105657225256\n      },\n      \"data\": {\n        \"computer\": \"Pass\",\n        \"label\": \"Pass\",\n        \"inputs\": [\n          {\n            \"id\": \"Pass0.0906613692536935-undefined\"\n          }\n        ],\n        \"outputs\": [\n          {\n            \"id\": \"Pass0.0906613692536935-undefined\"\n          }\n        ]\n      },\n      \"type\": \"dataStoryNode\",\n      \"selected\": true,\n      \"positionAbsolute\": {\n        \"x\": 373.1397321248163,\n        \"y\": 201.0105657225256\n      },\n      \"dragging\": false\n    }\n  ],\n  \"edges\": [\n    {\n      \"source\": \"Signal0.7993711459744541\",\n      \"sourceHandle\": \"Signal0.7993711459744541-undefined\",\n      \"target\": \"Pass0.0906613692536935\",\n      \"targetHandle\": \"Pass0.0906613692536935-undefined\",\n      \"id\": \"reactflow__edge-Signal0.7993711459744541Signal0.7993711459744541-undefined-Pass0.0906613692536935Pass0.0906613692536935-undefined\"\n    }\n  ],\n  \"viewport\": {\n    \"x\": 0,\n    \"y\": 0,\n    \"zoom\": 1\n  }\n}\n*/\n\nexport class DiagramFactory {\n  fromReactFlow(flow: any): Diagram {    \n    const nodes = flow.nodes.map((flowNode: any) => {\n      return new Node({\n        id: flowNode.id,\n        type: flowNode.data.computer,\n        inputs: flowNode.data.inputs.map((input: any) => {\n          // This should be passed in a property\n          return new Port(input.id, input.id.split(\".\").pop())\n        }),\n        outputs: flowNode.data.outputs.map((output: any) => {\n          // This should be passed in a property\n          return new Port(output.id, output.id.split(\".\").pop())\n        }),\n        // continue with PARAMS here!\n        params: flowNode.data.params || {},   \n      })\n    })\n\n    const links = flow.edges.map((edge: any) => {\n      return new Link(edge.id, edge.sourceHandle, edge.targetHandle)\n    })\n\n    return new Diagram(nodes, links)\n  }\n}\n\n\n/*\n{\n  \"nodes\": [\n    {\n      \"width\": 128,\n      \"height\": 52,\n      \"id\": \"Signal.1\",\n      \"position\": {\n        \"x\": 355.29217094488496,\n        \"y\": 226.10303220463445\n      },\n      \"data\": {\n        \"computer\": \"Signal\",\n        \"label\": \"Signal\",\n        \"inputs\": [],\n        \"outputs\": [\n          {\n            \"id\": \"Signal.1.output\",\n            \"name\": \"output\"\n          }\n        ]\n      },\n      \"type\": \"dataStoryNode\",\n      \"positionAbsolute\": {\n        \"x\": 355.29217094488496,\n        \"y\": 226.10303220463445\n      }\n    },\n    {\n      \"width\": 128,\n      \"height\": 78,\n      \"id\": \"Pass.1\",\n      \"position\": {\n        \"x\": 603.8344401401514,\n        \"y\": 250.84269792454666\n      },\n      \"data\": {\n        \"computer\": \"Pass\",\n        \"label\": \"Pass\",\n        \"inputs\": [\n          {\n            \"id\": \"Pass.1.input\",\n            \"name\": \"input\"\n          }\n        ],\n        \"outputs\": [\n          {\n            \"id\": \"Pass.1.output\",\n            \"name\": \"output\"\n          }\n        ]\n      },\n      \"type\": \"dataStoryNode\",\n      \"selected\": true,\n      \"positionAbsolute\": {\n        \"x\": 603.8344401401514,\n        \"y\": 250.84269792454666\n      },\n      \"dragging\": false\n    }\n  ],\n  \"edges\": [\n    {\n      \"source\": \"Signal.1\",\n      \"sourceHandle\": \"Signal.1.output\",\n      \"target\": \"Pass.1\",\n      \"targetHandle\": \"Pass.1.input\",\n      \"id\": \"Signal.1.output-->Pass.1.input\"\n    }\n  ],\n  \"viewport\": {\n    \"x\": -8.799999999999999,\n    \"y\": 0,\n    \"zoom\": 1\n  }\n}\n{\n  \"nodes\": [\n    {\n      \"id\": \"Signal.1\",\n      \"type\": \"Signal\",\n      \"inputs\": [],\n      \"outputs\": [\n        {\n          \"id\": \"Signal.1.output\",\n          \"name\": \"Signal.1.output\"\n        }\n      ]\n    },\n    {\n      \"id\": \"Pass.1\",\n      \"type\": \"Pass\",\n      \"inputs\": [\n        {\n          \"id\": \"Pass.1.input\",\n          \"name\": \"Pass.1.input\"\n        }\n      ],\n      \"outputs\": [\n        {\n          \"id\": \"Pass.1.output\",\n          \"name\": \"Pass.1.output\"\n        }\n      ]\n    }\n  ],\n  \"links\": [\n    {\n      \"id\": \"Signal.1.output-->Pass.1.input\",\n      \"sourcePortId\": \"Signal.1.output\",\n      \"targetPortId\": \"Pass.1.input\"\n    }\n  ]\n}\n*/",
  "InputDevice.ts": "import { LinkId } from \"./Link\"\nimport { Item } from \"./Item\"\nimport { PortId } from \"./Port\"\n\ntype InputStatus = 'AWAITING' | 'COMPLETE' | 'EXHAUSTED'\n\ntype LinkItems = Record<LinkId, Item[]>\n\n/**\n * Example:\n * {\n *   input: {\n *     'Source.1.output<--->Target.1.input': [1, 2]\n *     'Source.2.output<--->Target.1.input': [3, 4, 5]\n *   },\n *   another: {\n  *    'Source.3.output<--->Target.1.another': ['a text']\n *   }\n * }\n */\nexport type InputTree = Record<PortId, LinkItems>\n\nexport interface InputDeviceInterface {\n  pull: (count?: number) => Item[]\n  pullFrom: (name: string, count?: number) => Item[]\n}\n\nexport class InputDevice implements InputDeviceInterface {\n  constructor(private inputTree: InputTree = {}) {}\n\n  // haveItemsAtInput(name: string): boolean {}\n\n  // haveAllItemsAtInput(name: string): boolean {}\n\n  // haveNoItemsAtInput(name: string): boolean {}\n\n  /**\n   * Shorthand to pull items at 'input'\n   */\n  pull(count?: number) {\n    return this.pullFrom('input', count)\n  }\n\n  /**\n   * Removes and return items at edges connected to input with name \n   */\n  pullFrom(name: string, count?: number) {\n    let remaining = count || Infinity\n    const pulled: Item[] = []\n    const connectedLinks = this.inputTree[name]\n    const incomingItemLists = Object.values(connectedLinks)\n\n    for(const itemList of incomingItemLists) {\n      // splice will *removes* them from the inputTree\n      const taken = itemList.splice(0, remaining)\n      pulled.push(...taken)\n      remaining -= taken.length\n      if(remaining === 0) break\n    }\n\n    return pulled\n  }\n\n  /**\n   * Shorthand to set items while testing\n   */\n  setItemsAt(portName: string, linkId: LinkId, items: Item[]) {\n    this.inputTree[portName][linkId] = items\n  }\n}",
  "InputDeviceFactory.ts": "import { Diagram } from \"./Diagram\"\nimport { InputDevice, InputTree } from \"./InputDevice\"\nimport { Item } from \"./Item\"\nimport { Node } from \"./Node\"\n\nexport const InputDeviceFactory = {\n  create: (node: Node, diagram: Diagram): InputDevice => {\n    let tree: InputTree = {}\n\n    for(const input of node.inputs) {\n      tree[input.name] = {}\n\n      for(const link of diagram.linksConnectedToPortId(input.id)) {\n        tree[input.name][link.id] = []\n      }\n    }\n\n    return new InputDevice(tree)\n  },\n\n  createWithItemsAtFirstLink: (\n    node: Node,\n    diagram: Diagram,\n    inputs: {[key: string]: Item[]} = {}\n  ): InputDevice => {\n    let tree: InputTree = {}\n\n    for(const input of node.inputs) {\n      tree[input.name] = {}\n\n      const connectedLinks = diagram.linksConnectedToPortId(input.id)\n\n      if(connectedLinks.length > 1) throw new Error('Cannot create InputDevice with items at first link when there are multiple links connected to the input port')\n\n      for(const link of connectedLinks) {\n        tree[input.name][link.id] = inputs[input.name] || []\n      }\n    }\n\n    return new InputDevice(tree)\n  }\n}",
  "InputTreeFactory.ts": "import { Diagram } from \"./Diagram\";\n\nexport const InputTreeFactory = {\n  fromDiagram(diagram: Diagram) {\n\n  }\n}",
  "Link.ts": "import { PortId } from \"./Port\";\n\nexport type LinkId = string\nexport class Link {\n  constructor(\n    public id: LinkId,\n    public sourcePortId: PortId,\n    public targetPortId: PortId,\n  ) {}\n}\n",
  "Item.ts": "export type Item = object | string | number | null | undefined | boolean | Array<any>\n\nexport type ObjectItem = Record<string, any>",
  "Node.ts": "import { Param } from \"./Param\"\nimport { Port } from \"./Port\"\n\nexport type NodeId = string\n\nexport type NodeOptions = {\n  id: NodeId,\n  type: string,  \n  inputs: Port[],\n  outputs: Port[],\n  params?: Record<string, Param>,\n}\n\nexport class Node {\n  id: NodeId\n  type: string\n  inputs: Port[]\n  outputs: Port[]\n  params: Record<string, Param> = {}\n\n  constructor(options: NodeOptions) {\n    this.id = options.id\n    this.type = options.type\n    this.inputs = options.inputs\n    this.outputs = options.outputs\n    this.params = options.params || {}\n  }\n}",
  "NullStorage.ts": "import { Item } from \"./Item\";\nimport { Storage } from \"./Storage\";\n\nexport class NullStorage implements Storage {\n  currentExecutionId = '1'\n  \n  async init() {}\n  async createExecution() {}\n  async putExecutionItems(key: string, items: Item[]) {}\n}",
  "OutputDevice.ts": "import { LinkId } from \"./Link\"\nimport { Item } from \"./Item\"\nimport { PortId } from \"./Port\"\n\ntype LinkItems = Record<LinkId, Item[]>\n\nexport type OutputTree = Record<PortId, LinkItems>\n\nexport interface OutputDeviceInterface {\n  push(items: Item[]): void\n  pushTo(name: string, items: Item[]): void\n  itemsAt?(name: string): Item[]\n}\n\nexport class OutputDevice implements OutputDeviceInterface {\n  constructor(\n    private outputTree: OutputTree = {},\n    private linkCounts: Map<LinkId, number>,\n  ) {}\n\n  push(items: Item[]) {\n    return this.pushTo('output', items)\n  }\n\n  pushTo(name: string, items: Item[]) {\n    const connectedLinks = this.outputTree[name]\n    const outgoingItemLists = Object.values(connectedLinks)\n\n    // Update items on link\n    for(const itemList of outgoingItemLists) {\n      itemList.push(...items)\n    }\n\n    // Update link counts\n    for(const linkId of Object.keys(connectedLinks)) {\n      const count = this.linkCounts.get(linkId)!\n      this.linkCounts.set(linkId, count + items.length)\n    }\n  }\n\n  itemsOutputtedThrough(name: string): Item[] {\n    const connectedLinks = this.outputTree[name]\n    const [firstLinkItems] = Object.values(connectedLinks)\n\n    return firstLinkItems\n  }\n}",
  "OutputDeviceFactory.ts": "import { Diagram } from \"./Diagram\"\nimport { OutputDevice, OutputTree } from \"./OutputDevice\"\nimport { Node } from \"./Node\"\n\nexport const OutputDeviceFactory = {\n  create: (node: Node, diagram: Diagram): OutputDevice => {\n    let tree: OutputTree = {}\n\n    for(const output of node.outputs) {\n      tree[output.name] = {}\n\n      for(const link of diagram.linksConnectedToPortId(output.id)) {\n        tree[output.name][link.id] = []\n      }\n    }\n\n    const linkCounts = new Map<string, number>();\n\n    return new OutputDevice(tree, linkCounts)\n  }\n}",
  "Param.ts": "export type ParamValue = any\n\nexport type Param = {\n  id: string\n  name: string\n  type: string\n  value?: ParamValue\n  placeholder?: string,\n  selectOptions?: string[],\n}\n\nexport const name = {\n  id: 'name',\n  name: 'name',\n  type: 'string',\n  value: '',\n}\n\nexport const label = {\n  id: 'label',\n  name: 'label',\n  type: 'string',\n  value: '',\n}\n\nexport const DefaultParams = { name, label }",
  "ParamBuilder.ts": "import { Param } from \"./Param\"\n\nexport const string = (name: string) => new ParamBuilder(name, 'string')\nexport const number = (name: string) => new ParamBuilder(name, 'number')\nexport const json = (name: string) => new ParamBuilder(name, 'json')\nexport const select = (name: string) => new ParamBuilder(name, 'select')\n\nexport class ParamBuilder {\n  selectOptions?: string[]\n\n  constructor(private name: string, private type: string) {}\n\n  value(value: any): ParamBuilder {\n    this.value = value\n\n    return this\n  }\n\n  options(options: string[]): ParamBuilder {\n    this.selectOptions = options\n\n    return this\n  }\n\n  get(): Param {\n    return {\n      id: this.name,\n      name: this.name,\n      type: this.type,\n      value: this.value,\n      selectOptions: this.selectOptions,\n    }\n  }\n}",
  "ParamsDevice.ts": "import { Param } from \"./Param\";\n\ntype ParamId = string\n\nexport type ParamsDevice = {\n  [key: ParamId]: Param['value'],\n}",
  "Port.ts": "export type PortId = string;\n\nexport class Port {\n  constructor(public id: PortId, public name: string) {}\n}",
  "deriveFrom.ts": "import { ComputerFactory } from \"./Computer\";\nimport { ParamValue } from \"./Param\";\n\nexport type DeriveFromOptions = {\n  name: string,\n  params: Record<string, ParamValue>,\n  tags?: string[],\n}\n\nexport const deriveFrom = (\n  computerFactory: ComputerFactory,\n  options: Record<string, ParamValue>\n) => {\n  return () => {\n    const template = computerFactory();\n    template.name = options.name;\n\n    template.tags = [\n      ...(template.tags || []),\n      ...(options.tags || []),\n    ]\n\n    // TODO is this nasty?\n    if(!template.params) template.params = {}\n  \n    for (const [paramName, paramValue] of Object.entries(options.params || {})) {\n      template.params[paramName].value = paramValue\n    }\n  \n    return template\n  }\n}",
  "sampleDiagram.ts": "export const sampleDiagram = `{\n  \"nodes\": [\n    {\n      \"width\": 90,\n      \"height\": 52,\n      \"id\": \"Scalar.1\",\n      \"position\": {\n        \"x\": 100,\n        \"y\": 100\n      },\n      \"data\": {\n        \"computer\": \"Scalar\",\n        \"label\": \"Scalar (1)\",\n        \"inputs\": [],\n        \"outputs\": [\n          {\n            \"id\": \"Scalar.1.output\",\n            \"name\": \"output\"\n          }\n        ]\n      },\n      \"type\": \"dataStoryNode\",\n      \"positionAbsolute\": {\n        \"x\": 100,\n        \"y\": 100\n      }\n    },\n    {\n      \"width\": 119,\n      \"height\": 78,\n      \"id\": \"Multiply.1\",\n      \"position\": {\n        \"x\": 300,\n        \"y\": 100\n      },\n      \"data\": {\n        \"computer\": \"Multiply\",\n        \"label\": \"Multiply (* 2)\",\n        \"inputs\": [\n          {\n            \"id\": \"Multiply.1.input\",\n            \"name\": \"input\"\n          }\n        ],\n        \"outputs\": [\n          {\n            \"id\": \"Multiply.1.output\",\n            \"name\": \"output\"\n          }\n        ]\n      },\n      \"type\": \"dataStoryNode\",\n      \"positionAbsolute\": {\n        \"x\": 300,\n        \"y\": 100\n      }\n    },\n    {\n      \"width\": 69,\n      \"height\": 52,\n      \"id\": \"Log.1\",\n      \"position\": {\n        \"x\": 500,\n        \"y\": 100\n      },\n      \"data\": {\n        \"computer\": \"Log\",\n        \"label\": \"Log\",\n        \"inputs\": [\n          {\n            \"id\": \"Log.1.input\",\n            \"name\": \"input\"\n          }\n        ],\n        \"outputs\": []\n      },\n      \"type\": \"dataStoryNode\",\n      \"positionAbsolute\": {\n        \"x\": 500,\n        \"y\": 100\n      }\n    }\n  ],\n  \"edges\": [\n    {\n      \"id\": \"Scalar.1.output<--->Multiply.1.input\",\n      \"source\": \"Scalar.1\",\n      \"target\": \"Multiply.1\",\n      \"sourceHandle\": \"Scalar.1.output\",\n      \"targetHandle\": \"Multiply.1.input\",\n      \"label\": 582\n    },\n    {\n      \"id\": \"Multiply.1.output<--->Log.1.input\",\n      \"source\": \"Multiply.1\",\n      \"target\": \"Log.1\",\n      \"sourceHandle\": \"Multiply.1.output\",\n      \"targetHandle\": \"Log.1.input\",\n      \"label\": 464\n    }\n  ],\n  \"viewport\": {\n    \"x\": 0,\n    \"y\": 0,\n    \"zoom\": 1\n  }\n}`"
}